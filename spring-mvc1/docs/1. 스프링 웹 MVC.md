## 웹 서버, 웹 애플리케이션 서버

### 웹 - HTTP 기반

### 모든 것이 HTTP

#### HTTP 메시지에 모든 것을 전송

- HTML, TEXT
- 이미지, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송 가능
- 서버 간에 데이터를 주고받을 때도 HTTP 사용

<br>

### 웹 서버(Web Server)

- HTTP 기반으로 동작
- 정적 리소스 제공, 기타 부가 기능
- 정적(파일) HTML, CSS, JS, 이미지, 영상
- 예) NGINX, APACHE

<br>

### 웹 애플리케이션 서버(WAS - Web Application Server)

- HTTP 기반으로 동작
- 웹 서버 기능 포함 + 정적 리소스 제공 가능
- 프로그램 코드를 실행해서 애플리케이션 로직 수행
    - 사용자에 따라 다른 화면을 제공한다.
    - 동적 HTML, HTTP API(JSON)
    - 서블릿, JSP, 스프링 MVC
- 예) 톰캣 Jetty, Undertow

<br>

### 웹 서버, 웹 애플리케이션 서버(WAS) 차이

- 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직
- 사실 둘의 용어 경계가 모호하다.
    - 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함(플러그인 설치해서)
    - 웹 애플리케이션 서버도 웹 서버의 기능을 제공함
- 자바는 서블릿 컨테이너 기능을 제공하면 WAS
    - 서블릿 없이 자바 코드를 실행하는 서버 프레임워크도 있음
- WAS는 애플리케이션 코드를 실행하는 데 더 특화

<br>

### 웹 시스템 구성 - WAS, DB

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/99e44316-04a8-49d8-9405-0f0eec20dd9f width="80%" height="80%"/><br>
- WAS, DB만으로 시스템 구성 가능
- WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능
- 그러나 WAS가 너무 많은 역할을 담당해서 서버 과부하 우려가 있음
- 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있음
- WAS 장애시 오류 화면도 노출 불가능

<br>

### 웹 시스템 구성 - WEB, WAS, DB

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/f0f47c26-e2bf-41e5-b9af-4ff19dcf4f29 width="80%" height="80%"/><br>

- 정적 리소스는 웹 서버가 처리
- 웹 서버는 애플리케이션 로직 같은 동적인 처리가 필요하면 WAS에 요청을 위임
    - WAS는 중요한 애플리케이션 로직 처리 전담

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/0c2894f0-9467-452e-ae22-8c02d30d7d9f width="80%" height="80%"/><br>

- 효율적인 리소스 관리
    - 정적 리소스가 많이 사용되면 웹 서버를 증설한다.
    - 애플리케이션 리소스가 많이 사용된다면 WAS를 증설한다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/9c48d30b-cbd1-48ca-8e2f-6e06f5df44f4  width="85%" height="85%"/><br>

- 정적 리소스만 제공하는 웹 서버는 잘 죽지 않는다.
    - 단순히 파일을 읽어서 제공하기 때문
- 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽는다.
    - WAS, DB 장애시 웹 서버로 오류 화면 제공 가능하다.
- 만약 API만 사용한다면 웹 서버 없어도 된다. 화면 띄울 필요가 없기 때문

<br><br>

## 서블릿

### 서버에서 처리해야 하는 업무

- 웹 애플리케이션 서버를 직접 구현해야 한다면 의미 있는 비즈니스 로직은 적은데 전후 과정으로 구현해야 할 점들이 너무 많다.
    - 이런 단점을 해결하기 위해 서블릿이 탄생했다.
- 서블릿을 지원하는 WAS 사용
    
    <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/0e951c42-21da-4f80-9ca1-b24da955d521 width="80%" height="80%"/><br>


<br>

### 서블릿

#### 특징

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
 @Override
 protected void service(HttpServletRequest request, HttpServletResponse response){
 //애플리케이션 로직
 }
}
```

- `urlPatterns(/hello)`의 url이 호출되면 서블릿 코드가 실행된다.
- HTTP 요청 정보를 편리하게 사용할 수 있는 `HttpServletRequest`
- HTTP 응답 정보를 편리하게 제공할 수 있는 `HttpServletResponse`
- 개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있다.
    - 그래도 HTTP 스펙은 기본으로 알아야 잘 활용할 수 있겠죠?

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/15bfb248-73b2-4a8e-8ddf-582a04bef56b width="80%" height="80%"/><br>

#### HTTP 요청, 응답 흐름

- HTTP 요청 시
    - WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
    - 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
    - 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
    - WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

<br>

### 서블릿 컨테이너

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/81b56383-841d-4442-8dee-4673a2db19b4  width="60%" height="60%"/><br>

- 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
- 서블릿 객체는 [싱글톤](https://github.com/muyaaho/spring-basic/blob/main/docs/05%20%EC%8B%B1%EA%B8%80%ED%86%A4%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88.md#%EC%8B%B1%EA%B8%80%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88)으로 관리된다.
    - 고객의 요청이 올 때마다 계속 객체를 생성하는 것은 비효율적이다.
    - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용한다.
    - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근한다.
    - **공유 변수 사용을 주의한다.**
    - 서블릿 컨테이너 종료 시 함께 종료된다.
- JSP도 서블릿으로 변환되어 사용
- 동시 요청을 위한 멀티 스레드 처리 지원

<br><br>

## 동시 요청 - 멀티 스레드

### 스레드

- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 스레드이다. (프로세스는 프로그램 실행)
- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 스레드가 실행된다.
- 스레드가 없다면 자바 애플리케이션 실행이 불가능하다.
- 스레드는 한 번에 하나의 코드 라인만 수행한다.
- 동시 처리가 필요하면 스레드를 추가로 생성한다.

<br>

### 다중 요청 - 스레드 하나 사용

- 요청 1이 처리 중일 때 요청 2가 온다면 둘 다 죽는 현상이 발생할 수도 있다. (기다리다 timeout)

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/488a75d7-2c18-49f3-ae18-e4c21e075ba6 width="80%" height="80%"/><br>

<br>

### 요청마다 스레드 생성

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/fa482e3f-6312-4720-ac63-85d4702610c4 width="80%" height="80%"/><br>

- 요청1의 처리 지연 상관없이 요청2를 수행한다.

#### 장점

- 동시 요청을 처리할 수 있다.
- 리소스(CPU, 메모리)가 허용할 때까지 처리 가능하다.
- 하나의 스레드가 지연되어도, 나머지 스레드는 정상 작동한다.

#### 단점

- 스레드는 생성 비용이 매우 비싸다.
    - 고객의 요청이 올 때마다 스레드를 생성하면, 응답 속도가 느려진다.
- 스레드는 컨텍스트 스위칭 비용이 발생한다.
- 스레드 생성에 제한이 없다.
    - 고객 요청이 너무 많이 오면 CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

<br>

### 스레드 풀

#### 요청마다 스레드 생성의 단점 보완

- 특징
    
    <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/2d0ac605-a859-4285-8db6-8dd8977c2aaf width="80%" height="80%"/><br>

    - 필요한 스레드를 스레드 풀에 보관하고 관리한다.
    - 스레드 풀에 생성할 수 있는 스레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정
- 사용
    - 스레드가 필요하면, 이미 생성되어 있는 스레드를 스레드 풀에서 꺼내 사용한다.
    - 사용을 종료하면 스레드 풀에 해당 스레드를 반납한다.
    - 최대 스레드가 모두 사용 중이어서 스레드 풀에 스레드가 없으면?
        
        <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/3cfe2aa6-cf08-4393-8be9-3b477bad18e5 width="80%" height="80%"/><br>
        - 기다리는 요청은 거절하거나 특정 숫자만큼 대기하도록 설정할 수 있다.
- 장점
    - 스레드가 미리 생성되어 있으므로, 스레드를 생성하고 종료하는 비용이 절약되고 응답시간이 빠르다.
    - 생성할 수 있는 스레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

#### 실무 팁

- WAS의 주요 튜닝 포인트는 최대 스레드(max thread) 수이다.
- 이 값을 너무 낮게 설정한다면?
    
    <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/2c53dc63-fe2d-4242-8f16-852a5a523fba width="80%" height="80%"/><br>

    - 동시 요청이 많을 때 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연이 발생한다.
    - 여기 예시처럼 응답 지연이 일어났는데 CPU가 5%밖에 사용되지 않은 건 개발자 입장에서는 부끄러운 일이라고 한다. 50% 사용돼서 이런 에러가 발생해야 하는데 그렇다면 서버를 늘리지 않고 1개를 10배로 사용할 수 있기 때문에
- 이 값을 너무 높게 설정한다면?
    - 동시 요청이 많을 때 CPU, 메모리 리소스 임계점 초과로 서버가 다운된다.
- 장애 발생 시 어떻게 해야 하나요?
    - 클라우드면 일단 서버부터 늘리고 이후에 튜닝한다.
    - 클라우드가 아니면 열심히 튜닝한다.

#### 스레드 풀의 적정 숫자

- 적정 숫자는 어떻게 찾나요?
- n개, 몇 개 정해진 것이 아니라 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다르다.
- 성능 테스트를 하면서 찾아낸다.
    - 최대한 실제 서비스와 유사하게 성능 테스트를 시도한다.
    - 툴: 아파치 ab, 제이미터, nGrinder

<br>

### WAS의 멀티 스레드 지원 - 핵심

- 멀티 스레드에 대한 부분은 WAS가 처리
- **개발자가 멀티 스레드 관련 코드를 신경 쓰지 않아도 된다.**
- 개발자는 마치 **싱글 스레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발**하면 된다.
- 멀티 스레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)은 주의해서 사용한다.

<br><br>

## HTML, HTTP API, CSR, SSR

### 정적 리소스

- 고정된 HTML 파일, CSS, JS, 이미지, 영상 등 제공
- 주로 웹 브라우저

<br>

### HTML 페이지

- 동적으로 필요한 HTML 파일을 생성해서 전달
- 웹 브라우저는 HTML을 해석한다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/4b5815df-6ef1-4760-81fa-8adcec85612a width="80%" height="80%"/><br>

- 서버에서 HTML을 생성한다.

<br>

### HTTP API

- HTML이 아니라 데이터를 전달한다.
- 주로 JSON 형식을 사용한다.
- 다양한 시스템에서 호출된다.
    
    <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/47a3c50c-1c80-4234-96a4-ce3b410dbb19 width="80%" height="80%"/><br>

- 데이터만 주고받는다. UI 화면이 필요하면 클라이언트가 별도로 처리한다.
- UI 클라이언트 접점
    - 앱 클라이언트(아이폰, 안드로이드, PC 앱)
    - 웹 브라우저에서 자바스크립트를 통한 HTTP API 호출
    - React, Vue.js 같은 웹 클라이언트
- 서버 to 서버
    - 주문 서버 → 결제 서버
    - 기업 간 데이터 통신
- 개발자는 정적 리소스, HTML 페이지(동적), HTTP API를 어떻게 할지 모두 고민해야 한다.

<br>

### 서버 사이드 렌더링, 클라이언트 사이드 렌더링

#### SSR - 서버 사이드 렌더링

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/f23484eb-72b9-4364-850f-a3e99c5f93f4 width="80%" height="80%"/><br>

- HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달한다.
- 주로 정적인 화면에서 사용된다.
- 관련 기술: JSP, 타임리프 (백엔드 개발자)

#### CSR - 클라이언트 사이드 렌더링

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/b21e478b-c3fd-4713-ae03-d7d6bc6dcd53 width="80%" height="80%"/><br>

- HTML 결과를, 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용한다.
- 주로 동적인 화면에서 사용된다. 웹 환경을 마치 앱처럼 필요한 부분 변경할 수 있다.
    - 예) 구글 지도, Gmail, 구글 캘린더
- 관련 기술: React, Vue.js (프론트엔드 개발자)

#### 참고

- React, Vue.js를 CSR + SSR 동시에 지원하는 웹 프레임워크도 있다.
- SSR을 사용하더라도, 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능하다.

<br>

### 어디까지 알아야 하나요? - 백엔드 개발자 입장에서 UI 기술

#### 백엔드 - 서버 사이드 렌더링 기술

- JSP, 타임리프
- 화면이 정적이고, 복잡하지 않을 때 사용
- 백엔드 개발자는 서버 사이드 렌더링 기술 학습을 필수로 해야 한다.

#### 웹 프론트엔드 - 클라이언트 사이드 렌더링 기술

- React, Vue.js
- 복잡하고 동적인 UI 사용
- 웹 프론트엔드 개발자의 전문 분야

#### 선택과 집중

- 백엔드 개발자의 웹 프론트엔드 기술 학습은 옵션이다.
- 백엔드 개발자는 서버, DB, 인프라 등등 수많은 백엔드 기술을 공부해야 하기 때문이다.
- 웹 프론트엔드 기술도 알면 나쁘진 않지만 깊이 있게 잘하려면 숙련에 오랜 시간이 필요하다.

<br><br>

## 자바 백엔드 웹 기술 역사

### 자바 웹 기술 역사

#### 과거 기술

- 서블릿 - 1997
    - HTML 생성 어려움
- JSP - 1999
    - HTML 생성 편리하지만, 비즈니스 로직까지 많은 역할 담당
- 서블릿, JSP 조합 MVC 패턴 사용
    - 모델, 뷰, 컨트롤러로 역할 나누어 개발
- MVC 프레임워크 춘추 전국 시대 - 2000년대 초 ~ 2010년 초
    - MVC 패턴을 기반으로 한 수많은 프레임워크가 나왔음
    - MVC 패턴 자동화, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능 지원
    - 스트럿츠, 웹워크, 스프링 MVC(과거 버전)

#### 현재 사용 기술

- **어노테이션 기반의 스프링 MVC 등장**
    - 어노테이션으로 편리하게 사용 가능하다.
    - 스프링에서 나온 MVC 기술로 프레임워크를 합쳐서 사용하거나 그러지 않아도 된다.
- **스프링 부트의 등장**
    - 개발자가 불편해했던 점들을 해결해 준다.
    - 스프링 부트는 서버를 내장한다.
        - 과거에는 서버에 WAS를 직접 설치하고 소스는 War 파일을 만들어서 설치한 WAS에 배포한다.
    - 스프링 부트는 빌드 결과(Jar)에 WAS 서버를 포함하여 빌드 배포를 단순화했다.

#### 최신 기술 - 스프링 웹 기술의 분화

- Web Servlet - Spring MVC
- Web Reactive - Spring WebFlux

#### Spring WebFlux

- 특징
    - 최신 기술이다.
    - 비동기 넌 블러킹 처리
    - 최소 스레드로 최대 성능을 낸다. - 스레드 컨텍스트 스위칭 비용 효율화
    - 함수형 스타일 개발 - 동시처리 코드 효율화
    - 서블릿 기술 사용 X(netty 사용)
- 하지만
    - 기술적 난이도가 매우 높다.
    - 아직 RDB 지원이 부족하다.
    - 일반 MVC 스레드 모델도 충분히 빠르다.
    - 실무에서 아직 많이 사용하지 않는다.

<br>

### 자바 뷰 템플릿 역사

#### HTML을 편리하게 생성하는 뷰 기능

- JSP
    - 속도가 느리고 기능이 부족하다.
- Freemarker, Velocity
    - 속도 문제를 해결하고 다양한 기능을 제공한다.
- Thymeleaf
    - 네추럴 템츨릿: HTML 모양을 유지하면서 뷰 템플릿 적용이 가능하다.
    - 스프링 MVC와 강력한 기능 통합(스프링에서 밀어주고 있다)
    - 최선이 선택이다. 단 성능은 프리마커, 벨로시티가 더 빠르다(근데 웬만한 사이트는 성능 이슈가 크게 있진 않다.)
