## 로깅 간단히 알아보기

### 로깅 라이브러리

스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리(`spring-boot-starter-logging`)가 함께 포함된다.

스프링 부트 로깅 라이브러리는 기본으로 다음 로깅 라이브러리를 사용한다.

- SLF4J
    - Logback, Log4J, Log4J2등 로그 라이브러리를 통합해서 인터페이스로 제공하는 것
- Logback
    - SLF4J의 구현체 중 하나

<br>

### 로그 선언

- `private Logger log = LoggerFactory.getLogger(getClass());`
- `private static final Logger log = LoggerFactory.getLogger(Xxx.class)`
- `@Slf4j` : 롬복 사용 가능

<br>

### 로그 호출

- `log.info("hello")`
- `System.out.println(”hello”)`
    - 로그 레벨에 상관없이 모두 출력된다. 만약 실제 운영을 한다면 로그 폭탄을 맞을 수도 있다.

시스템 콘솔로 직접 출력하는 것 보다 로그를 사용하면 다음과 같은 장점이 있다. 실무에서는 항상 로그를 사용해야 한다.

<br>

```java
@Slf4j
@RestController
public class LogTestController {
//    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest() {
        String name = "Spring";

        log.trace("trace log={}", name);
        log.debug("debug log={}", name);
        log.info(" info log={}", name);
        log.warn(" warn log={}", name);
        log.error("error log={}", name);

        return "ok";
    }
}

```

#### 매핑 정보

- `@RestController`
    - `@Controller`: 반환 값이 String이면 뷰 이름으로 인식되어 뷰를 찾고 뷰가 랜더링된다.
    - `@RestController`: 반환 값으로 뷰를 찾지 않고 HTTP 메시지 바디에 바로 입력한다.
        
      <img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/f837aa1a-efec-44dd-980f-6ec855ed0039 width="50%" height="50%"/><br>


<br>

#### 테스트

- 로그가 출력되는 포맷 확인
    - 시간, 로그 레벨, 프로세스 ID, 스레드명, 클래스명, 로그 메시지
- 로그 레벨 설정 변경 가능
    - LEVEL: `TRACE > DEBUG > INFO > WARN > ERROR`
    - 개발 서버는 DEBUG 출력
    - 운영 서버는 INFO 출력
- `@Slf4j`로 변경하면 `private final Logger log = LoggerFactory.getLogger(getClass());` 코드가 자동으로 적용된다.

<br>

#### 로그 레벨 설정

```
#application.properties

#전체 로그 레벨 설정(기본 info)
logging.level.root=info
#hello.springmvc 패키지와 그 하위 로그 레벨 설정
logging.level.hello.springmvc=debug
```

<br>

### 올바른 로그 사용법

- `log.debug("data="+data)`
    - 이렇게 사용하면 혼납니다.
    - 로그 레벨을 info로 설정해도 해당 코드에 있는 “data = “+data가 실제 실행된다.
        - 만약 레벨이 info고 코드에 debug가 있으면 debug를 넘어간다.
    - 더하기 연산이 먼저 실행 → debug인 걸 나중에 확인 → 현재 로그 레벨이 info라면 그냥 넘어감
    - 많은 코드를 이렇게 작성했다면 실행되지 않는 더하기 연산이 실행되면서 자원이 낭비될 수 있다.
- `log.debug("data={}", data)`
    - 로그 레벨을 info로 설정하면 아무 일도 발생하지 않는다.

<br>

### 로그 사용 시 장점

- 스레드 정보, 클래스 이름 밭은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에는 모든 로그를 출력하고, 운영 서버에는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다. 특히 파일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
- 성능도 System.out보다 좋다. 그래서 실무에는 꼭 로그를 사용해야 한다.











<br><br>

## 요청 매핑

### MappingController

```java
@RestController
public class MappingController {

    private Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping(value = "/hello-basic", method = RequestMethod.GET)
    public String helloBasic() {
        log.info("helloBasic");
        return "ok";
    }
}
```

<br>

#### 매핑 정보

- `@RestController`
    - `@Controller`는 반환 값이 `String`이면 뷰 이름으로 인식되어 **뷰를 찾고 뷰가 렌더링**된다.
    - `@RestController`는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP 메시지 바디**에 바로 입력한다. 따라서 실행 결과로 ok 메시지를 받을 수 있다.
- `@RequestMapping("/hello-basic")`
    - `/hello-basic` URL로 호출이 오면 이 메서드가 실행되도록 매핑한다.
    - 대부분의 속성에서 배열이 제공되므로 다중 설정이 가능하다. `{"/hello-basic", "/hello-go"}`

<br>

### HTTP 메서드

`@RequestMapping`에 `method` 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다. 

GET, HEAD, POST, PUT, PATCH, DELETE 모두 허용된다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/ac6f766a-3baa-4641-8195-e93777f82988 width="70%" height="70%"/><br>

<br>

### HTTP 메서드 매핑

```java
 	/**
 * method 특정 HTTP 메서드 요청만 허용
 * GET, HEAD, POST, PUT, PATCH, DELETE
 */
@RequestMapping(value = "/hello-basic", method = RequestMethod.GET)
public String helloBasic() {
    log.info("helloBasic");
    return "ok";
}
```

만약 여기에 GET 이외의 요청을 하면 HTTP는 405 상태 코드(Method Not Allowed)를 반환한다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/1b3d1192-caf2-4430-a001-969b896800bd width="70%" height="70%"/><br>

참고로 REST API라서 JSON 형식으로 확인 가능하다.

<br>

### HTTP 메서드 매핑 축약

```java
/**
 * 편리한 축약 애노테이션 (코드보기)
 * @GetMapping
 * @PostMapping
 * @PutMapping
 * @DeleteMapping
 * @PatchMapping
 */
    @GetMapping(value="/mapping-get-v2")
    public String mappingGetV2() {
        log.info("mapping-get-v2");
        return "ok";
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/74a46d9b-8939-4144-b667-f33333248f39 width="70%" height="70%"/><br>

HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다. 코드 내부에는 `@RequsetMapping`과 method를 지정해서 사용하는 것을 확인할 수 있다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/92858af5-d35d-4c24-a94b-b9aed9165c3a  width="50%" height="50%"/><br>

<br>

### PathVariable(경로 변수) 사용

```java
    /**
     * PathVariable 사용
     * 변수명이 같으면 생략 가능
     * @PathVariable("userId") String userId -> @PathVariable String userId
     */
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable("userId") String data) {
        log.info("mappingPath userid={}", data);
        return "ok";
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/9e421349-b7c0-4e27-bfaa-e9ea67b8aae0 width="70%" height="70%"/><br>

- 최근 HTTP API는 다음과 같이 리소스 경로에 식별자를 넣는 스타일을 선호한다.
    - `/mapping/userA`
    - `/users/1`
- `@RequestMapping`은 URL 경로를 템플릿화 할 수 있는데, `@PathVariable`을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.
- `@PathVariable`의 이름과 파라미터 이름이 같으면 생략할 수 있다.
    
    ```java
    @GetMapping("/mapping/{userid}")
    public String mappingPath(@PathVariable String userId) {
    ...
    ```
    

<br>

### PathVariable 사용 - 다중

```java
    /**
     * PathVariable 다중 사용
     */
    @GetMapping("/mapping/users/{userId}/orders/{orderId}")
    public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {
        log.info("mappingPath userId={}, orderId={}", userId, orderId);
        return "ok";
    }

```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/18541e8d-8719-4c3c-9cb9-698ffdae3e56  width="50%" height="50%"/><br>

<br>

### 특정 파라미터 조건 매핑

```java
    /**
     * 파라미터로 추가 매핑
     * params="mode",
     * params="!mode"
     * params="mode=debug"
     * params="mode!=debug" (! = )
     * params = {"mode=debug","data=good"}
     */
    @GetMapping(value="/mapping-param", params = "mode=debug")
    public String mappingParam() {
        log.info("mappingParam");
        return "ok";
    }
```

특정 파라미터가 있거나 없는 조건을 추가할 수 있다.

<br>

### 특정 헤더 조건 매핑

```java
    /**
 * 특정 헤더로 추가 매핑
 * headers="mode",
 * headers="!mode"
 * headers="mode=debug"
 * headers="mode!=debug" (! = )
 */
    @GetMapping(value="/mapping-header", headers = "mode=debug")
    public String mappingHeader() {
        log.info("mappingHeader");
        return "ok";
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/ce340452-5a54-450c-b59a-e63a5ab373b1 width="70%" height="70%"/><br>

파라미터 매핑과 비슷하지만 HTTP 헤더를 사용한다. postman에서 실행해 볼 때 주의

<br>

### 미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume

```java
    /**
     * Content-Type 헤더 기반 추가 매핑 Media Type
     * consumes="application/json"
     * consumes="!application/json"
     * consumes="application/*"
     * consumes="*\/*"
     * MediaType.APPLICATION_JSON_VALUE
     */
    @PostMapping(value = "/mapping-consume", consumes = "text/html")
    public String mappingConsumes() {
        log.info("mappingConsumes");
        return "ok";
    }
```

HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑한다.

만약 맞지 않으면 HTTP 406 상태 코드(Not Acceptable)을 반환한다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/f7da3b33-586f-41ba-90b8-90754e23bda0 width="70%" height="70%"/><br>

예시

```java
produces = "text/plain"
produces = {"text/plain", "application/*"}
produces = MediaType.TEXT_PLAIN_VALUE // 아무래도 이게 낫죠
produces = "text/plain;charset=UTF-8"
```

[Accept](https://github.com/muyaaho/http-basic/blob/768e1fbd4da5817c44a0a1ea059ff985e6ec7592/docs/7.http-header1.md#%ED%98%91%EC%83%81%EC%BD%98%ED%85%90%EC%B8%A0-%EB%84%A4%EA%B3%A0%EC%8B%9C%EC%97%90%EC%8B%9C%EC%85%98)에 따른 결과

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/4766b739-277b-46af-8757-12edb9eacf9c width="70%" height="70%"/><br>

json으로 나오는 모습

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/832081d4-ec42-4b55-8070-aeec45f803da width="70%" height="70%"/><br>

html으로 나오는 모습, accept에 따라 달라진다.

<br><br>

## 요청 매핑 - API 예시

회원 관리를 HTTP API로 만든다 생각하고 매핑을 어떻게 하는지 알아보자. (실제 데이터가 넘어가는 부분은 생략하고 URL 매핑만 한다.)

<br>

### 회원 관리 API

| 기능  | Method | URL |
| --- | --- | --- |
| 회원 목록 조회 | GET | /users |
| 회원 등록 | POST | /users |
| 회원 조회 | GET | /users/{userId} |
| 회원 수정 | PATCH | /users/{userId} |
| 회원 삭제 | DELETE | /users/{userId} |

<br>

### MappingClassController

```java
@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    @GetMapping()
    public String user() {
        return "get users";
    }

    @PostMapping()
    public String addUser() {
        return "post user";
    }

    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId=" + userId;
    }

    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId=" + userId;
    }

    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId=" + userId;
    }
}
```

- `@RequestMapping("/mapping/users")`
    - 클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.

<br><br>

## HTTP 요청 - 기본, 헤더 조회

애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다. HTTP 헤더 정보를 조회하는 방법을 알아보자.

### RequestHeaderController

```java
@Slf4j
@RestController
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCooker", required = false) String cookie) {
        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);

        return "ok";
    }
}

```

```
RequestHeaderController    : request=org.apache.catalina.connector.RequestFacade@2421f2cd
RequestHeaderController    : response=org.springframework.web.context.request.async.StandardServletAsyncWebRequest$LifecycleHttpServletResponse@2659d036
RequestHeaderController    : httpMethod=GET
RequestHeaderController    : locale=ko_KR
RequestHeaderController    : headerMap={content-type=[application/json], user-agent=[PostmanRuntime/7.39.0], accept=[*/*], postman-token=[e9bb4aee-b5d2-43fd-946b-6e397a90ade1], host=[localhost:8080], accept-encoding=[gzip, deflate, br], connection=[keep-alive], content-length=[32]}
RequestHeaderController    : header host=localhost:8080
RequestHeaderController    : myCookie=null
```

- `HttpServletRequest`
- `HttpServletResponse`
- `HttpMethod`
    - HTTP 메서드를 조회한다.
- `Locale`
    - Locale 정보를 조회한다.
- `@RequestHeader MultivalueMap<String, String> headerMap`
    - 모든 HTTP 헤더를 MultiValueMap 형식으로 조회한다.
- `@RequestHeader("host") String host`
    - 특정 HTTP 헤더를 조회한다.
    - 속성
        - 필수 값 여부: `required`
        - 기본 값 속성: `defaultValue`
- `@CookieValue(value= "myCookie", required = false) String cookie`
    - 특정 쿠키를 조회한다.
    - 속성
        - 필수 값 여부: `required`
        - 기본값: `defaultValue`

<br>

#### MultiValueMap 

- MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
- HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.
    
    `keyA=value1&key2=value2`
    
    ```java
    MultiValueMap<String, String> map = new LinkedMultiValueMap();
    map.add("keyA", "value1");
    map.add("keyA", "value2");
    
    //[value1,value2]
    List<String> values = map.get("keyA");
    ```
    

<br>

#### @Slf4j

```java
private static final org.slf4j.Logger log =
org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class);
```

다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자는 편리하게 `log`를 사용하면 된다.






<!-- 2024/07/01 -->
<br><br>

## HTTP 요청 파라미터

### HTTP 요청 데이터 조회 - 개요

HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법을 알아보자.

**클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.**

- **GET - 쿼리 파라미터**
    - `/url**?username=hello&age=20**`
    - 메시지 바디 없이 URL의 쿼리 파라미터에 데이터를 포함해서 전달
    - 예) 검색,필터, 페이징 등에서 많이 사용하는 방식
- **POST - HTML Form**
    - `content-type: application/x-www-form-urlencoded`
    - 메시지 바디에 쿼리 파라미터 형식으로 전달 `username=hello&age`
    - 예) 회원 가입, 상품 주문, HTML Form 사용
- **HTTP message body**에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT, PATCH

<br>

### 요청 파라미터 - 쿼리 파라미터, HTML Form

`HttpServletRequest`의 `request.getParameter()`을 사용하면 다음 두 가지 요청 파라미터를 조회할 수 있다.

#### GET, 쿼리 파라미터 전송

예시

```html
http://localhost:8080/request-param?username=hello&age=20
```

#### POST, HTML Form 전송

예시

```html
POST /request-param ...
content-type: application/x-www-form-urlencoded

username=hello&age=20
```

GET 쿼리 파라미터 전송 방식이든, POST HTML Form 전송 방식이든 둘 다 형식이 같으므로 구분 없이 조회할 수 있다. 이것을 간단히 **요청 파라미터(request parameter) 조회**라고 한다.

지금부터 스프링 요청 파라미터를 조회하는 방법을 단계적으로 알아보자.

#### RequestParamController

```java
@Slf4j
@Controller
public class RequestParamController {

    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username={}, age={}", username, age);

        response.getWriter().write("ok");
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/752670ff-6dd4-4422-89ea-02155eaaab12 width="70%" height="70%"/><br>

#### `request.getParameter()`

여기서는 단순히 HttpServletRequest가 제공하는 방식으로 요청 파라미터를 조회했다.

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/f18f0638-a08b-42be-8740-4e6b5b7e65c1 width="70%" height="70%"/><br>

jar를 사용하면 내부를 통한 웹앱 톰캣을 사용할 수 없기 때문에 정적 리소스는 static 하위에 넣어서 쓰면 된다.

<br><br>

## HTTP 요청 파라미터 - @RequestParam

스프링이 제공하는 `@RequestParam`을 사용하면 요청 파라미터를 매우 편리하게 사용할 수 있다.

```java
    /**
 * @RequestParam 사용
 * - 파라미터 이름으로 바인딩
 * @ResponseBody 추가
 * - View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력
 */ 
 
 // public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException { -> 
    @ResponseBody
    @RequestMapping("/request-param-v2")
    public String requestParamV2(
            @RequestParam("username") String memberName,
            @RequestParam("age") int memberAge
    ) {
        log.info("username={}, age={}", memberName, memberAge);
        return "ok";
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/5df4bdeb-ddd5-4578-8c40-c57d6728dccd width="70%" height="70%"/><br>

- `@RequestParam`: 파라미터 이름으로 바인딩
- `@ResponseBody`: View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력

**@RequestParam**의 `name(value)` 속성이 파라미터 이름으로 사용된다.

- @RequestParam(”**username**”) String **memberName**
- ⇒ request.getParameter(”**username**”)

<br>

### requestParamV3

```java
    @ResponseBody
    @RequestMapping("/request-param-v3")
    public String requestParamV3(
				    // @RequestParam("username") String memberName, -> 
            @RequestParam String username,
            @RequestParam int age
    ) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

HTTP 파라미터 이름이 변수 이름과 같으면 `@RequestParam(name="xx")` 생략 가능하다.

<br>

### requestParamV4

```java
    @ResponseBody
    @RequestMapping("/request-param-v4")
    // (@RequestParam String username, @RequestParam int age) -> 
    public String requestParamV4(String username, int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

`String`, `int`, `Integer` 등의 단순 타입이면 `@RequestParam`도 생략 가능하다.

> **주의**
`@RequestParam` 어노테이션을 생략하면 스프링 MVC는 내부에서 `required=false`를 적용한다.
`required` 옵션은 다음에 설명한다.
> 

> **참고**
v3까지 어노테이션을 생략하는 것은 과하다는 강사님의 의견이 있다. 
v2까지가 적당하다.
> 

<br>

#### 파라미터 필수 여부 - requestParamRequired

```java
    @ResponseBody
    @RequestMapping("/request-param-required")
    public String requestParamRequired(
            @RequestParam(required = true) String username,
            @RequestParam(required = false) Integer age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/6fe06a79-8ea5-41e0-83bb-78ed6474560d width="70%" height="70%"/><br>

- `@RequestParam.required`
    - 파라미터 필수 여부
    - 기본값이 파라미터 필수(`true`)이다.
- `/request-param-required` 요청
    - `username`이 없으므로 400 예외가 발생한다.
    - age는 없어도 되지만 username은 무조건 있어야 한다.

<br>

#### 주의! - 파라미터 이름만 사용

```java
/request-param-required?username=
```

파라미터 이름만 있고 값이 없는 경우는 빈 문자로 통과된다. null (X)

<br>

#### 주의! - 기본형(primitive)에 null 입력

- `/request-param` 요청
- `@RequestParam(required=false) int age`
    - required 가 false라서 username만 입력해도 되는데 그렇게 되면 age에 null값이 들어가게 된다.
    - int 값에는 null을 입력할 수 없다. (500 예외 발생)
    - 따라서 null을 받을 수 있는 `Integer`로 변경하거나, 다음에 나오는 `defaultValue`를 사용한다.

<br>

#### 기본값 적용 - requestParamDefault

```java
    @ResponseBody
    @RequestMapping("/request-param-default")
    public String requestParamDefault(
            @RequestParam(required = true, defaultValue = "guest") String username,
            @RequestParam(required = false, defaultValue = "-1") int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

- 파라미터에 값이 없는 경우 `defaultValue`를 사용하면 기본값을 적용할 수 있다.
- 이미 기본값이 있기 때문에 `required`는 의미가 없다.
- `defaultValue`는 빈 문자의 경우에도 설정한 기본값이 적용된다.
    - `~~ defult?username=` 이렇게만 보내도 기본값이 적용된다.

<br>

#### 파라미터를 Map으로 조회하기 - requestParamMap

```java
    @ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
        log.info("username={}, age={}", paramMap.get("username"), paramMap.get("age"));
        return "ok";
    }
```

파라미터를 Map, [MultiValueMap](https://github.com/muyaaho/spring-mvc1/blob/main/docs/6.%20%EC%8A%A4%ED%94%84%EB%A7%81%20MVC%20-%20%EA%B8%B0%EB%B3%B8%20%EA%B8%B0%EB%8A%A5.md#multivaluemap)으로 조회할 수 있다.

- `@RequestParam Map`
    - `Map(key=value)`
- `@RequestParam MultiValueMap`
    - `MultiValueMap(key=[value1, value2, ...]`
    - 예) `(key=userIds, value=[id1, id2])`

파라미터의 값이 1개가 확실하다면 `Map`을 사용해도 되지만, 그렇지 않다면 `MultValueMap`을 사용하자.

<br><br>

## HTTP 요청 파라미터 - @ModelAttribute

실제 개발을 하면 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 한다.

스프링은 그 과정을 자동화해 주는 `@ModelAttribute`를 지원한다.

먼저 요청 파라미터를 바인딩 받을 객체를 만들자.

```java
@Data
public class HelloData {
    private String username;
    private int age;
}
```

- 롬복 `@Data`
    - `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsContructor`을 자동으로 적용해 준다.

### @ModelAttribute 적용 - modelAttributeV1

```java
    @ResponseBody
    @RequestMapping("/model-attribute-v1")
    public String modelAttribute(@ModelAttribute HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

- HelloData 객체가 생성되고, 요청 파라미터의 값도 모두 들어있다.
- 스프링 MVC는 `@ModelAttribute`가 있으면 다음을 실행한다.
    - `HelloData` 객체를 생성한다.
    - 요청 파라미터의 이름으로 `HelloData` 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력(바인딩)한다.
    - 예) 파라미터 이름이 `username`이면 `setUsername()` 메서드를 찾아서 호출하면서 값을 입력한다.

<br>

#### 프로퍼티

객체에 `getUsername()`, `setUsername()` 메서드가 있으면, 이 객체는 `username`이라는 프로퍼티를 가지고 있다.

`username` 프로퍼티 값을 변경하면 `setUsername()`이 호출되고, 조회하면 `getUsername()`이 호출된다.

<br>

#### 바인딩 오류

`age=abc` 처럼 숫자가 들어가야 할 곳에 문자를 넣으면 `BindException`이 발생한다. 자세한 내용은 검증 부분에서 다룬다.

<br>

### @ModelAttribute 생략 - modelAttributeV2

```java
    @ResponseBody
    @RequestMapping("/model-attribute-v2")
    public String modelAttributeV2(HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

- `@ModelAttribute`는 생략할 수 있다.
- 그런데 `@RequestParam`도 생략할 수 있으니, 혼란이 발생할 수 있다.
- 스프링은 해당 생략 시 다음과 같은 규칙을 적용한다.
    - `String`, `int`, `Integer`같은 단순 타입 = `@RequestParam`
    - 나머지 = `@ModelAttribute` (argument resolver로 지정해 둔 타입 외)

<br><br>

## HTTP 요청 메시지 - 단순 텍스트

서블릿에서 학습한 내용을 떠올려보자

- **HTTP message body**에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT, PATCH

요청 파라미터와 다르게, HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우는 `@RequestParam`, `@ModelAttribute`를 사용할 수 없다.

목표

- 가장 단순한 텍스트 메시지를 HTTP 메시지 바디에 담아서 전송하고, 읽어보자.
- HTTP 메시지 바디의 데이터를 `InputStream`을 사용해 직접 읽을 수 있다.

<br>

### RequestBodyStringController

```java
@Slf4j
@Controller
public class RequestBodyStringController {

    @PostMapping("/request-body-string-v1")
    public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messagebody={}", messageBody);

        response.getWriter().write("ok");
    }
}
```

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/5df0af3b-1158-4aa0-a639-cc71b08cf51d width="70%" height="70%"/><br>

<br>

### Input, Output 스트림, Reader - requestBodyStringV2

```java
    @PostMapping("/request-body-string-v2")
    public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException {
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messagebody={}", messageBody);
        responseWriter.write("ok");
    }
```

- **스프링 MVC는 다음 파라미터를 지원한다.**
    - InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
    - OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력

<br>

### HttpEntity - requestBodyStringV3

```java
    @PostMapping("/request-body-string-v3")
    public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) throws IOException {
        String messageBody = httpEntity.getBody();
        log.info("messagebody={}", messageBody);

        return new HttpEntity<>("ok");
    }
```

- **HttpEntity**: HTTP header, body 정보를 편리하게 조회
    - 메시지 바디 정보를 직접 조회
    - 요청 파라미터를 조회하는 기능과 관계없음 `@RequestParam` X, `@ModelAttribute` X
- **HttpEntity는 응답에도 사용 가능**
    - 메시지 바디 정보 직접 반환
    - 헤더 정보 포함 가능
    - view 조회 X

<br>

- `HttpEntity`를 상속받은 다음 객체들도 같은 기능을 제공한다.
- **RequestEntity**
    - HttpMethod, url 정보 추가, 요청에서 사용
- **ResponseEntity**
    - HTTP 상태 코드 설정 가능, 응답에서 사용
    - `return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED)`

> **참고**
스프링 MVC 내부에서 HTTP 메시지 바디를 읽어 문자나 객체로 변환해서 전달해 주는데, 이때 HTTP 메시지 컨버터(`HttpMessageConverter`) 라는 기능을 사용한다.
> 

<br>

### @RequestBody - requestBodyStringV4

```java
    @ResponseBody
    @PostMapping("/request-body-string-v4")
    public String requestBodyStringV4(@RequestBody String messageBody) throws IOException {
        log.info("messagebody={}", messageBody);

        return "ok";
    }
```

- **@RequestBody**
    - `@RequestBody`를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다. 참고로 헤더 정보가 필요하다면 `HttpEntitiy`를 사용하거나 `@RequestHeader`를 사용하면 된다.
    - 이렇게 메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 `@RequestParam`, `@ModelAttribute`와는 전혀 관계가 없다.
- **요청 파라미터 vs HTTP 메시지 바디**
    - 요청 파라미터를 조회하는 기능: `@RequestParam`, `@ModelAttribute`
    - HTTP 메시지 바디를 직접 조회하는 기능: `@RequestBody`
- **@ResponseBody**
    - `@ResponseBody`를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아 전달할 수 있다. 물론 이 경우에도 view를 사용하지 않는다.

<br><br>

## HTTP 요청 메시지 - JSON

### RequestBodyJsonController

```java
@Slf4j
@Controller
public class RequestBodyJsonController {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @PostMapping("/request-body-json-v1")
    public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody={}", messageBody);
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        response.getWriter().write("ok");
    }
    ...
}
```

- `HttpServletRequest`를 직접 사용해 HTTP 메시지 바디에서 데이터를 읽어와 문자로 변환한다.
- 문자로 된 JSON 데이터를 Jackson 라이브러리인 `objectMapper`를 사용해 자바 객체로 변환한다.

<br>

### requestBodyJsonV2 - @RequestBody 문자 변환

```java
    @ResponseBody
    @PostMapping("/request-body-json-v2")
    public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {
        log.info("messageBody={}", messageBody);
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

- 이전에 학습했던 `@RequestBody`를 사용해서 HTTP 메시지에서 데이터를 꺼내고 messageBody에 저장한다.
- 문자로 된 JSON 데이터인 `messageBody`를 `objectMapper`를 통해 자바 객체로 변환한다.

**문자로 변환하고 다시 json으로 변환하는 과정이 불편하다. @ModelAttribute처럼 객체로 한번에 변환할 수는 없을까?**

<br>

### requestBodyJsonV3 - @RequestBody 객체 변환

```java
    @ResponseBody
    @PostMapping("/request-body-json-v3")
    public String requestBodyJsonV3(@RequestBody HelloData helloData) throws IOException {
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

- **@RequestBody 객체 파라미터**
    - `@RequestBody HelloData data`
    - `@RequestBody`에 직접 만든 객체를 지정할 수 있다.
- `HttpEntity`, `@RequestBody`를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해 준다.
- HTTP 메시지 컨버터는 문자뿐만 아니라 JSON도 객체로 변환해 주는데, 우리가 방금 V2에서 했던 작업을 대신 처리해 준다.

<br>

#### @RequestBody는 생략 불가능

이 경우에 HelloData에 `@RequestBody`를 생략하면 `@ModelAttribute`가 적용되어 버린다.

`HelloData data` → `@ModelAttribute HelloData data`

따라서 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터를 처리하게 된다.

<br>

> **주의**
HTTP 요청 시에 content-type이 application/json인지 꼭 확인해야 한다. 그래야 JSON을 처리할 수 있는 HTTP 메시지 컨버터가 실행된다.
> 

<br>

### requestBodyJsonV4 - HttpEntity

```java
    @ResponseBody
    @PostMapping("/request-body-json-v4")
    public String requestBodyJsonV4(HttpEntity<HelloData> data) throws IOException {
        HelloData helloData = data.getBody();
        log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }
```

HttpEntity 사용

<br>

### requestBodyJsonV5

```java
    @ResponseBody
    @PostMapping("/request-body-json-v5")
    public HelloData requestBodyJsonV5(@RequestBody HelloData data) {
        log.info("username={}, age={}", data.getUsername(), data.getAge());

        return data;
    }
```

- `@ResponseBody`
    - 응답의 경우에도 `@ResponseBody`를 사용하면 해당 객체를 HTTP 메시지 바디에 직접 넣어줄 수 있다. 물론 이 경우에도 HttpEntity를 사용해도 된다.
- `@RequestBody` 요청
    - JSON 요청 → HTTP 메시지 컨버터 → 객체
- `@ResponseBody` 응답
    - 객체 → HTTP 메시지 컨버터 → JSON 응답

<br><br>

## HTTP 응답 - 정적 리소스, 뷰 템플릿

응답 부분에 초점을 맞추어 정리해 보자. 스프링에서 응답 데이터를 만드는 방법은 크게 3가지이다.

- 정적 리소스
    - 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는 **정적 리소스**를 사용한다.
- 뷰 템플릿 사용
    - 예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
- HTTP 메시지 사용
    - HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON같은 형식으로 데이터를 실어 보낸다.

<br>

### 정적 리소스

스프링 부트는 클래스패스의 다음 디렉터리에 있는 정적 리소스를 제공한다.

`/static` , `/public`, `/resources`, `/META-INF/resources`

- `src/main/resources`는 리소스를 보관하는 곳이고, 클래스 패스의 시작 경로이다.
- 따라서 다음 디렉터리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.

<br>

#### 정적 리소스 경로

- `src/main/resources/static`
- `src/main/resources/static/basic/hello-form.html`에 파일이 들어있으면 웹 브라우저에서 [`http://localhost:8080/basic/hello-form.html`을](http://localhost:8080/basic/hello-form.html을) 실행하면 된다.
- 정적 리소스는 해당 파일을 변경 없이 그대로 서비스하는 것이다.

<br>

### 뷰 템플릿

- 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.
- 일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다. 뷰 템플릿이 만들 수 있는 것이라면 뭐든지 가능하다.
- 스프링 부트는 기본 뷰 템플릿 경로를 제공한다.

<br>

#### 뷰 템플릿 경로

- `src/main/resources/templates`

<br>

#### 뷰 템플릿 생성

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p th:text="${data}">empty</p>
</body>
</html>
```

thymeleaf가 사용되었다.

<br>

#### ResponseViewController - 뷰 템플릿을 호출하는 컨트롤러

```java
@Controller
public class ResponseViewController {

    @RequestMapping("/response-view-v1")
    public ModelAndView responseViewV1() {
        ModelAndView mav = new ModelAndView("response/hello").addObject("data", "hello!");

        return mav;
    }

    @RequestMapping("/response-view-v2")
    public String responseViewV2(Model model) {
        model.addAttribute("data", "hello!");
        return "response/hello";
    }

    @RequestMapping("/response/hello")
    public void responseViewV3(Model model) {
        model.addAttribute("data", "hello!");
//        return "response/hello";/
    }
}
```

<br>

#### String을 반환하는 경우 - View or HTTP 메시지

- `@ResponseBody`가 **없으면** `response/hello`로 뷰 리졸버가 실행되어 뷰를 찾고 렌더링한다.
- `@ResponseBody`가 **있으면** 뷰 리졸버를 실행하지 않고, HTTP 메시지 바디에 직접 `response/hello`라는 문자가 입력된다.
- 여기서는 뷰의 논리 이름인 `response/hello`를 반환하면 다음 경로의 뷰 템플릿이 렌더링 되는 것을 확인할 수 있다.
- 실행: `templates/response/hello.html`

<br>

#### void를 반환하는 경우

- `@Controller`를 사용하고 `HttpServletResponse`, `OutputStream(Writer)` 같은 HTTP 메시지 바디를 처리하는 파라미터가 없으면 요청 URL을 참고해서 논리 뷰 이름으로 사용한다.
    - 요청 URL: `/response/hello`
    - 실행: `templates/response/hello.html`
- **참고로 이 방식은 명시성이 떨어지고 이렇게 딱 맞는 경우가 없어서 권장하지 않는다.**

<br>

#### HTTP 메시지

- `@ResponseBody`, `HttpEntity`를 사용하면 뷰 템플릿을 사용하는 것이 아니라 HTTP 메시지 바디에 직접 응답 데이터를 출력할 수 있다.

<br>

### Thymeleaf 스프링 부트 설정

프로젝트를 만들 때 https://start.spring.io/ 에서 이미 추가했다.

```java
// build.gradle
implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'`
```

- 스프링 부트가 자동으로 `ThymeleafViewResolver`와 필요한 스프링 빈들을 등록한다.
- 다음 설정도 사용한다. 기본값이기 때문에 변경이 필요할 때만 사용하면 된다.
    
    ```java
    // application.properties
    spring.thymeleaf.prefix=classpath:/templates/
    spring.thymeleaf.suffix=.html
    ```
    
- [추가 설정](https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-application-properties.html#common-application-properties-templating)

<br><br>

## HTTP 응답 - HTTP API, 메시지 바디에 직접 입력

HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON같은 형식으로 데이터를 실어 보낸다.

> **참고**
HTML이나 뷰 템플릿을 사용해도 HTTP 응답 메시지 바디에 HTML 데이터가 담겨서 전달된다. 여기서 설명하는 내용은 정적 리소스나 뷰 템플릿을 거치지 않고, 직접 HTTP 응답 메시지를 전달하는 경우를 말한다.
> 

<br>

### ResponseBodyController

```java
@Slf4j
@Controller
public class ResponseBodyController {

    @GetMapping("/response-body-string-v1")
    public void responseBodyV1(HttpServletResponse response) throws IOException {
        response.getWriter().write("ok");
    }

    @GetMapping("/response-body-string-v2")
    public ResponseEntity<String> responseBodyV2() throws IOException {
        return new ResponseEntity<>("ok", HttpStatus.OK);
    }

    @ResponseBody
    @GetMapping("/response-body-string-v3")
    public String responseBodyV3(){
        return "ok";
    }

    @GetMapping("/response-body-json-v1")
    public ResponseEntity<HelloData> responseBodyJsonV1() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);
        return new ResponseEntity<>(helloData, HttpStatus.OK);
    }

    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    @GetMapping("/response-body-json-v2")
    public HelloData responseBodyJsonV2() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);
        return helloData;
    }
}
```

#### responseBodyV1

- 서블릿을 직접 다룰 때처럼 `HttpServletResponse` 객체를 통해서 HTTP 메시지 바디에 직접 응답 `ok` 메시지를 전달한다.
- `response.getWriter().write("ok")`

<br>

#### responseBodyV2

- `ResponseEntity` 엔티티는 `HttpEntity`를 상속받았는데, `HttpEntity`는 HTTP 메시지의 헤더, 바디 정보를 가지고 있다. `ResponseEntity`는 여기에 더해서 HTTP 응답 코드를 설정할 수 있다.
- `HttpStatus.CREATED`로 변경하면 201 응답이 나가는 것을 확인할 수 있다.

<br>

#### responseBodyV3

- `@ResponseBody`를 사용하면 view를 사용하지 않고 HTTP 메시지 컨버터를 통해서 HTTP 메시지를 직접 입력할 수 있다. `ResponseEntity`도 동일한 방식으로 동작한다.

<br>

#### responseBodyJsonV1

- `ResponseEntity`를 반환한다. HTTP 메시지 컨버터를 통해서 JSON 형식으로 변환되어서 반환한다.

<br>

#### responseBodyJsonV2

- `ResponseEntity`는 HTTP 응답 코드를 설정할 수 있는데, `@ResponseBody`를 사용하면 이런 것을 설정하기 까다롭다.
- `@ResponseStatus(HttpStatus.OK)` 애노테이션을 사용하면 응답 코드도 설정할 수 있다.
- 물론 어노테이션이기 때문에 응답 코드를 동적으로 변경할 수는 없다. 프로그램 조건에 따라 동저긍로 변경하려면 `ResponseEntitiy`를 사용하면 된다.

<br>

### @RestController

- `@Controller` 대신에 `@RestController` 어노테이션을 사용하면, 해당 컨트롤러에 모두 `@ResponseBody`가 적용되는 효과가 있다.
- 따라서 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 데이터를 입력한다. 이름 그대로 Rest API(HTTP API)를 만들 때 사용하는 컨트롤러이다.
- 참고로 `@ResponseBody`는 클래스 레벨에 두면 전체 메서드에 적용되는데, `@RestController` 어노테이션 안에 `@ResponseBody`가 적용되어 있다.

<br>



<!---2024/07/03-->

<br><br>

## HTTP 메시지 컨버터

뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라, HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.

<br>

### @ResponseBody 사용 원리

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/8047c009-65ff-4577-8116-95be935599b1 width="80%" height="80%"/><br>

- `@ResponseBody` 사용
    - HTTP의 BODY에 문자 내용을 직접 반환
    - `viewResolver` 대신에 `HttpMessageConverter`가 동작
    - 기본 문자 처리: `StringHttpMessageConverter`
    - 기본 객체 처리: `MappingJackson2HttpMessageConverter`
    - byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있다.

> **참고**
응답의 경우 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 `HttpMessageConverter`가 선택된다.
> 

<br>

### 스프링 MVC는 다음 경우에 HTTP 메시지 컨버터를 적용한다.

- HTTP 요청: `@RequestBody`, `HttpEntity(RequestEntity)`
- HTTP 응답: `@ResponseBody`, `HttpEntity(ResponseEntity)`

<br>

### HTTP 메시지 컨버터 인터페이스

```java
public interface HttpMessageConverter<T> {

	boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
	boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);

	List<MediaType> getSupportedMediaTypes();

	default List<MediaType> getSupportedMediaTypes(Class<?> clazz) {
		return (canRead(clazz, null) || canWrite(clazz, null) ?
				getSupportedMediaTypes() : Collections.emptyList());
	}

	T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

	void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

}

```

- HTTP 메시지 컨버터는 HTTP 요청, HTTP 응답 둘 다 사용된다.
    - `canRead()`, `canWrite()`: 메시지 컨버터가 해당 클래스, 미디어 타입을 지원하는지 체크
    - `read()`, `write()`: 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능

<br>

#### 스프링 부트 기본 메시지 컨버터

```java
0 = ByteArrayHttpMessageConverter
1 = StringHttpMessageConverter
2 = MappingJackson2HttpMessageConverter
```

스프링 부트는 다양한 메시지 컨버터를 제공한다. 대상 클래스 타입과 미디어 타입을 체크해서 사용 여부를 결정한다. 만약 만족하지 않으면 다음 컨버터로 우선순위가 넘어간다.

주요 메시지 컨버터를 알아보자

- `ByteArrayHttpMessageConverter`
    - `byte[]` 데이터를 처리한다.
    - 클래스 타입: `byte[]`, 미디어 타입: `*/*`
    - 요청 예) `@RequestBody **byte[] data**`
    - 응답 예) `@ResponseBody return **byte[]**` 쓰기 미디어 타입 `application/octet-stream`
- `StringHttpMessageConverter`
    - `String` 문자로 데이터를 처리한다.
    - 클래스 타입: `String`, 미디어 타입: `*/*`
    - 요청 예) `@RequestBody **String data**`
    - 응답 예) `@ResponseBody return "ok"` 쓰기 미디어 타입 `text/plain`
- `MappingJackson2HttpMessageConverter`: application/json
    - 클래스 타입: 객체 또는 `HashMap`, 미디어타입 `application/json` 관련
    - 요청 예) `@RequestBody HelloData data`
    - 응답 예) `@ResponseBody return helloData` 쓰기 미디어 타입 `application/json` 관련

<br>

#### StringHttpMessageConverter

```java
// content-type: application/json

@RequestMapping
void hello(@RequestBody String data) {}
```

<br>

#### MappingJackson2HttpMessageConverter

```java
// content-type: application/json

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

<br>

#### 안되는 케이스

```java
// content-type: text/html

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

<br>

### HTTP 요청 데이터 읽기

- HTTP 요청이 오고, 컨트롤러에서 `@RequestBody`, `HttpEntity` 파라미터를 사용한다.
- 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 `canRead()`를 호출한다.
    - 대상 클래스 타입을 지원하는가
        - 예) `@RequestBody`의 대상 클래스 (`byte[]`, `String`, `HelloData`)
    - HTTP 요청의 Content-Type 미디어 타입을 지원하는가.
        - 예) `text/plain`, `application/json`, `*/*`
- `canRead()` 조건을 만족하면 `read()`를 호출해서 객체를 생성하고 반환한다.

<br>

### HTTP 응답 데이터 생성

- 컨트롤러에서 `@ResponseBody`, `HttpEntity`로 값이 반환된다.
- 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite()를 호출한다.
    - 대상 클래스 타입을 지원하는가
        - 예) return의 대상 클래스 (`byte[]`, `String`, `Hellodata`)
- `canWrite()` 조건을 만족하면 `write()`를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.

<br><br>

## 요청 매핑 핸들러 어댑터 구조

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/2f59d488-4c05-4027-b5ae-216900b26d7f width="80%" height="80%"/><br>

HTTP 메시지 컨버터는 스프링 MVC 어디쯤에서 사용되는 것일까?

- `@RequestMapping`을 처리하는 핸들러 어댑터인 `RequestMappingHandlerAdapter에 있다.

<br>

#### RequestMappingHandlerAdapter 동작 방식

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/22ee51fe-dc05-4ccb-b3c5-f707d0c4409b width="80%" height="80%"/><br>

<br>

#### ArgumentResolver

- 애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있다.
    - `HttpServletRequest`, `Model`
    - `@RequestParam`, `@ModelAttribute`같은 어노테이션
    - `@RequestBody`, `HttpEntity`같은 HTTP 메시지 처리
- 이렇게 파라미터를 유연하게 처리할 수 있는 이유가 바로 `ArgumentResolver` 덕분이다.
- 어노테이션 기반 컨트롤러를 처리하는 `RequestMappingHandlerAdapter`는 바로 이 `ArgumentResolver`를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다.
- 이렇게 파라미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.
- 스프링은 30개가 넘는 `ArgumentResolver`를 기본으로 제공한다.
    - [가능한 파라미터 목록](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html)
    - 참고로 인터페이스로 설계되어 있어 기능을 쉽게 추가할 수 있다.

<br>

### HandlerMethodArgumentResolver

```java
public interface HandlerMethodArgumentResolver {

	boolean supportsParameter(MethodParameter parameter);

	@Nullable
	Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;

}
```

<br>

#### 동작 방식

- `ArgumentResolver`의 `supportsParameter()`를 호출해서 해당 파라미터를 지원하는지 체크하고, 지원하면 `resolveArgument()`를 호출해서 실체 객체를 생성한다.
- 이렇게 생성된 객체가 컨트롤러 호출 시 넘어가는 것이다.

- 원한다면 `ArgumentResolver`를 확장해 원하는 기능을 지원하도록 할 수 있다.

<br>

### HandlerMethodReturnValueHandler

```java
public interface HandlerMethodReturnValueHandler {

	boolean supportsReturnType(MethodParameter returnType);

	void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;

}
```

- `HandlerMethodReturnValueHandler`를 줄여 `ReturnValueHandler`라 부른다.
- `ArgumentResolver`와 비슷한데, 이것은 응답 값을 변환하고 처리한다.
- 컨트롤러에서 String으로 뷰 이름을 반환해도 동작하는 이유가 `ReturnValueHandler`덕분이다.

<br>

### HTTP 메시지 컨버터

#### HTTP 메시지 컨버터 위치

<img src=https://github.com/muyaaho/spring-mvc1/assets/76798969/1de4d8f1-355c-4bdd-9081-f8bacb0d5f64 width="80%" height="80%"/><br>

- HTTP 메시지 컨버터는 어디쯤 있을까?
    - HTTP 메시지 컨버터를 사용하는 `@RequestBody`도 컨트롤러가 필요로 하는 파라미터의 값에 사용된다.
    - `@ResonseBody`의 경우도 컨트롤러의 반환 값을 이용한다.
- **요청**의 경우
    - `@RequestBody`를 처리하는 `ArgumentResolver`가 있고, `HttpEntity`를 처리하는 `ArgumentResolver`가 있다.
    - 이 `ArgumentResolver`들이 HTTP 메시지 컨버터를 사용해 필요한 객체를 생성하는 것이다.
- **응답**의 경우
    - `@ResponseBody`와 `HttpEntity`를 처리하는 `ReturnValueHandler`가 있다.
    - 그리고 여기에서 HTTP 메시지 컨버터를 호출해서 응답 결과를 만든다.
- 스프링 MVC는 `@RequestBody`와 `@ResponseBody`가 있으면 `RequestResponseBodyMethodProcessor(ArgumentResolver, ReturnValueHandler 둘 다 구현)`을 사용한다.
- `HttpEntity`가 있으면 `HttpEntityMethodProcessor(ArgumentResolver, ReturnValueHandler
둘 다 구현)`을 사용한다.

<br>

### 확장

- 스프링은 다음을 모두 인터페이스로 제공한다. 필요하면 언제든지 기능을 확장할 수 있다.
    - `HandlerMethodArgumentResolver`
    - `HandlerMethodReturnValueHandler`
    - `HttpMessageConverter`
- 스프링이 필요한 대부분의 기능을 제공하기 때문에 실제 기능을 확장할 일이 많지는 않다.
- 기능 확장은 `WebMvcConfigurer`를 상속받아 스프링 빈으로 등록하면 된다.

